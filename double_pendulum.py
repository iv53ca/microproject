# -*- coding: utf-8 -*-
"""Double pendulum.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZemAN8YhGpJfdzuVDyC8kJzJ3WtfKlqY
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
import matplotlib.pyplot as plt
import matplotlib.cm as cm
# %matplotlib inline

figsize = 6
dpi = 600

import numpy as np
import matplotlib.pyplot as plt
from IPython.display import display, Image
import matplotlib.animation as animation

def plot_position(x_1, y_1, x_2, y_2, theta_1, theta_2, t):
    """ Plots the motion of the double pendulum in the
    xy-plane, as well as the angles and the angular
    velocities as a function of time.
    
    x_1     : array-like, size(n,). x-posision of mass 1
    y_1     : array-like, size(n,). y-posision of mass 1
    x_2     : array-like, size(n,). x-posision of mass 2
    y_2     : array-like, size(n,). y-posision of mass 2
    theta_1 : array-like, size(n,). The first angle in the double pendulum
    theta_2 : array-like, size(n,). The second angle in the double pendulum
    t      : array-like, size(n,). Time
    """
    plt.figure(figsize=(2*figsize, figsize), dpi=dpi)

    # xy-plot
    L = 1.1*(l1 + l2)
    ax = plt.subplot(2, 2, (1, 3), autoscale_on=False, xlim=(-L, L), ylim=(-L, L))
    ax.plot(x_1, y_1, label=r"Track $m_1$")
    ax.plot(x_2, y_2, label=r"Track $m_2$")
    ax.plot([0, x_1[0], x_2[0]], [0, y_1[0], y_2[0]], "-o", label="Initial position", c='k')
    plt.ylabel(r"$y/L$")
    plt.xlabel(r"$x/L$")
    ax.legend()

    # xt-plot
    ax = plt.subplot(2, 2, 2)
    ax.plot(t, theta_1, label=r"$\theta_1(t)$")
    ax.plot(t, theta_2, label=r"$\theta_2(t)$")
    plt.ylabel(r"$\theta$, [rad]")
    plt.xlabel(r"$t$, [s]")
    ax.legend()
    plt.xlim([0, np.max(t)])

    # yt-plot
    ax = plt.subplot(2, 2, 4)
    ax.plot(t, omega_1, label=r"$\omega_1(t)$")
    ax.plot(t, omega_2, label=r"$\omega_2(t)$")
    plt.ylabel(r"$\omega$, [rad/s]")
    plt.xlabel(r"$t$, [s]")
    plt.xlim([0, np.max(t)])
    ax.legend()

    plt.show()
    
def create_animation(filename, x_1, y_1, x_2, y_2, tmax, l1, l2):
    """ Creates an animation of the double pendulum.
    The animation is stored as a .gif and displayed.
    
    filename : string. Filename of the animation
    x_1     : array-like, size(n,). x-posision of mass 1
    y_1     : array-like, size(n,). y-posision of mass 1
    x_2     : array-like, size(n,). x-posision of mass 2
    y_2     : array-like, size(n,). y-posision of mass 2
    tmax   : array-like, size(n,). Final time
    l1, l2 : float. Length of rod 1 and 2
    """
    
    fig = plt.figure(figsize=(4, 4), dpi=60)
    L = 1.1*(l1 + l2)
    ax = fig.add_subplot(111, autoscale_on=False, xlim=(-L, L), ylim=(-L, L))

    tail1, = ax.plot([],[],'r') # Tail for m2
    line, = ax.plot([], [], '-o', lw=2, c="k")
    time_template = r'$t = %.1fs$'
    time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)
    ax.set_aspect('equal')
    ax.axis('off')

    # Calculates the number of frames
    FPS = 15
    framesNum = int(FPS*tmax)
    frames = np.floor(np.linspace(0, len(x_1) - 1, framesNum)).astype(np.int)

    def init():
        line.set_data([], [])
        tail1.set_data([], [])
        time_text.set_text('')
        return line, time_text

    def animate(i):
        line.set_data([0, x_1[i], x_2[i]], [0, y_1[i], y_2[i]])
        tail1.set_data(x_2[:i], y_2[:i])
        time_text.set_text(time_template % (i*dt))
        return line, time_text, tail1

    anim = animation.FuncAnimation(fig, animate, frames=frames)

    # Save animation. Try using "ffmpeg" if "imagemagick" does not work
    anim.save(filename + '.gif', writer='pillow', fps=FPS)

    # Close plot
    plt.close(anim._fig)

    # Display the animation
    with open(filename + '.gif','rb') as file:
        display(Image(file.read()))
        
def plot_phasespace(theta_1, omega_1, theta_2, omega_2):
    """ Creates a phase-space plot for the double pendulum
    for (theta, omega).
    
    theta_1 : array-like, size(n,). The first angle in the double pendulum
    omega_1     : array-like, size(n,). Angular velocity of the first angle
    theta_2 : array-like, size(n,). The second angle in the double pendulum
    omega_2     : array-like, size(n,). Angular velocity of the second angle
    """
    
    plt.figure(figsize=(2*figsize, figsize), dpi=dpi)
    plt.title(r"Phase-space diagram, $\theta_{10}=%.1f$, $\theta_{20}=%.1f$ "%(theta_1[0], theta_2[0])
             + r"$\omega_{10}=%.1f$, $\omega_{20}=%.1f$"%(omega_1[0], omega_2[0]))
    plt.plot(theta_1, omega_1, label=r"$i=1$")
    plt.plot(theta_2, omega_2, label=r"$i=2$")
    plt.legend()
    plt.xlabel(r"$\theta_i$, [rad]")
    plt.ylabel(r"$\omega_i$, [rad/s]")
    xlim = [np.min(theta_1), np.max(theta_1), np.min(theta_2), np.max(theta_2)]
    plt.xlim(np.min(xlim), np.max(xlim))
    plt.show()

def RHS(z, t, l1, l2, m1, m2, g):
    theta_1, omega_1, theta_2, omega_2 = z
    d_omega_1 = (-g*(2*m1 + m2)*np.sin(theta_1) - m2*g*np.sin(theta_1 - 2*theta_2) - 2*np.sin(theta_1 - theta_2)*m2*(omega_2**2*l2 + omega_1**2*l1*np.cos(theta_1 - theta_2)))/(l1*(2*m1 + m2 - m2*np.cos(2*theta_1 - 2*theta_2)))
    d_omega_2 = (2*np.sin(theta_1 - theta_2)*(omega_1**2*l1*(m1 + m2) + g*(m1 + m2)*np.cos(theta_1) + omega_2**2*l2*m2*np.cos(theta_1 - theta_2)))/(l2*(2*m1 + m2 - m2*np.cos(2*theta_1 - 2*theta_2)))
    
    return omega_1, d_omega_1, omega_2, d_omega_2

def to_cartesian(theta_1, omega_1, theta_2, omega_2, l1, l2):
    x_1 = l1*np.sin(theta_1)
    y_1 = -l1*np.cos(theta_1)
    x_2 = x_1 + l2*np.sin(theta_2)
    y_2 = y_1 - l2*np.cos(theta_2)
    vel_x_1 = omega_1*l1*np.cos(theta_1)
    vel_y_1 = omega_1*l1*np.sin(theta_1)
    vel_x_2 = vel_x_1 + omega_2*l2*np.cos(theta_2)
    vel_y_2 = vel_y_1 + omega_2*l2*np.sin(theta_2)
    
    return x_1, y_1, x_2, y_2, vel_x_1, vel_y_1, vel_x_2, vel_y_2

l1, l2 = 0.32, 0.32
m1, m2 = 3., 1.

z0 = [-0.56, 0., -0.49, 0.]
tmax, dt = 50, 0.01
t = np.arange(0, tmax+dt, dt)

z = odeint(RHS, z0, t, args=(l1, l2, m1, m2, g))

theta_1, omega_1, theta_2, omega_2 = z[:,0], z[:,1], z[:,2], z[:,3]
x_1, y_1, x_2, y_2, vel_x_1, vel_y_1, vel_x_2, vel_y_2 = to_cartesian(theta_1, omega_1, theta_2, omega_2, l1, l2)

plot_position(x_1, y_1, x_2, y_2, theta_1, theta_2, t)

create_animation("double_pendulum", x_1, y_1, x_2, y_2, tmax, l1, l2)

def RHS_simple(z, t, L, g):
    """ Возвращает правую часть
    обыкновенного дифференциального уравнения, описывающего
    простой маятник.
    """
    theta, w = z
    wdot = -np.sin(theta)*g/L
    return w, wdot

w0 = [2., 4., 6, 6.2, 6.3, 6.4, 7.]
L = 1.
g = 9.81
tmax_simp, dt_simp = 4, 0.01
t_simp = np.arange(0, tmax+dt, dt)

plt.figure(figsize=(2*figsize, figsize), dpi=dpi)
plt.title(r"Phase-space diagram, simple pendulum, $\theta_0=0$")
for i in range(len(w0)):
    z = odeint(RHS_simple, [0, w0[i]], t_simp, args=(L, g))
    theta_simp, w_simp = z[:,0], z[:,1]
    color = cm.rainbow(float(i + 1)/len(w0)) # Creating colormap
    plt.plot(theta_simp, w_simp, c=color, label=r"$\omega_0=%.1fs^{-1}$"%(w0[i]))
    plt.plot(theta_simp, -w_simp, c=color)
    plt.plot(-theta_simp, w_simp, c=color)
    plt.plot(-theta_simp, -w_simp, c=color)
plt.xlabel(r"$x(t)/L$")
plt.ylabel(r"$v(t)/(L/s)$")
plt.xlim([-np.pi, 2*np.pi])
plt.legend()
plt.show()

plot_phasespace(theta_1, omega_1, theta_2, omega_2)

time = np.empty(len(y_1))
for i in range(len(y_1)):
    time[i] = i*(30/len(y_1))
ax = plt.subplot()
ax.plot(theta_1, omega_1)

arrX_upper = np.empty(251)
arrY_upper = np.empty(251)
cnt = 0
with open ('upper_3.txt') as file:
    for line in file:
        X, Y = line.split()
        X = float(X.replace(",", "."))
        Y = float(Y.replace(",", "."))
        arrX_upper[cnt] = X
        arrY_upper[cnt] = Y
        cnt += 1
        
        
arrX_lower = np.empty(251)
arrY_lower = np.empty(251)
cnt = 0
with open ('lower_3.txt') as file:
    for line in file:
        X, Y = line.split()
        #rint(X.replace(",", "."))
        X = float(X.replace(",", "."))
        Y = float(Y.replace(",", "."))
        arrX_lower[cnt] = X
        arrY_lower[cnt] = Y
        #rint(X)
        cnt += 1

time = np.empty(251)
for i in range(251):
    time[i] = i*(8/251)
        
        
# theta_1_exp = np.empty(375)
# theta_2_exp = np.empty(375)
# for i in range(375):
#     theta_1_exp[i] = np.arctan(arrX_upper[i]/abs(arrY_upper[i]))
#     theta_2_exp[i] = np.arctan((arrX_lower[i] - arrX_upper[i])/abs(arrY_lower[i]))


fig, ax = plt.subplots()
ax.plot(time[25:] - 0.75, arrX_lower[25:], label='experiment')
ax.plot(t[:900], x_2[:900], label='theory')
# ax.plot(time, arrX_lower, label='experiment')
# ax.plot(t[:1200], x_2[:1200], label='theory')
ax.set_xlabel("t, [s]")
ax.set_ylabel("x, [m]")
ax.set_title(r"$\theta_{10}=%.1f$, $\theta_{20}=%.1f$ "%(z0[0], z0[2]))
ax.legend()